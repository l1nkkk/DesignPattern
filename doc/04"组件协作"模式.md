- [Template Method 模板模式](#Template-Method-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F)
  - [动机(Motivation)](#%E5%8A%A8%E6%9C%BAMotivation)
  - [代码](#%E4%BB%A3%E7%A0%81)
    - [没使用Template之前](#%E6%B2%A1%E4%BD%BF%E7%94%A8Template%E4%B9%8B%E5%89%8D)
    - [使用Template之后](#%E4%BD%BF%E7%94%A8Template%E4%B9%8B%E5%90%8E)
    - [对比（早绑定和晚绑定）](#%E5%AF%B9%E6%AF%94%E6%97%A9%E7%BB%91%E5%AE%9A%E5%92%8C%E6%99%9A%E7%BB%91%E5%AE%9A)
  - [模式定义](#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89)
  - [类结构](#%E7%B1%BB%E7%BB%93%E6%9E%84)
  - [要点总结](#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93)

现代软件专业分工之后的第一个结果是“**框架与应用程序的划分**”**(注：我们在写程序的时候一定会使用到默写library或者framework)**，“组件协作”模式通过**晚期绑定**，来实现框架与应用程序之间的**松耦合**，是二者之间协作时常用的模式。  
典型模式
- Template Method模板模式
- Observer / Event 事件模式
- Strategy 策略模式
- **(注：在组件协作模式中介绍这三种模式并不说明其他模式与此无关，只是这里这三个模式在组件协作中体现最明显)**
  
# Template Method 模板模式
## 动机(Motivation)
在软件构建过程中，对于某一项任务，它常常有**稳定的整体操作结构**，但各个**子步骤却有很多改变的需求**，或者由于固有的原因（比如框架与应用之间的关系）而无**法和任务的整体结构同时实现**(注：必然出现一个早编写一个晚编写)。  
如何在**确定稳定操作结构的前提下**，来灵活应对各个子步骤的**变化或者晚期实现需求**？  
## 代码
首先这个应用的整体结构是固定的。而子步骤会变。
### 没使用Template之前
template1_lib.cpp为程序库开发人员所开发。  
template2_app.cpp为应用程序开发人员开发。  
问题：其实框架开发人员对于整体的流程以及设计好了的，常常不需要做更改且稳定，所以框架开发人员完全可以自己把步骤写进去自己的框架里；由框架开发人员来写。  
![](../pic/WeChat&#32;Image_20191029220014.png)  
template1_lib.cpp
```c++
//程序库开发人员
class Library{

public:
// 里面实现了以下三个步骤
	void Step1(){
		//...
	}

    void Step3(){
		//...
    }

    void Step5(){
		//...
    }
};
```
template1_app.cpp
```c++
//应用程序开发人员
class Application{
public:
// 应用开发人员编写的步骤
	bool Step2(){
		//...
    }

    void Step4(){
		//...
    }
};

int main()
{
	// 整体操作结构
	Library lib();
	Application app();

	lib.Step1();

	if (app.Step2()){
		lib.Step3();
	}

	for (int i = 0; i < 4; i++){
		app.Step4();
	}

	lib.Step5();

}
```
### 使用Template之后
![](../pic/WeChat&#32;Image_20191029220219.png)  
这段代码揭示了绝代多数软件的稳定中有变化的特点，稳定的代码(run)写成非虚函数，而变化的写成虚函数。模块模式必须run稳定，必须要有一个稳定的算法骨架可以被重用，这里基于假设run稳定。但是如果杠精假设这那全都不稳定，那么最后会发现所有软件体系结构都不稳定，那么什么设计模式都不能使用。当然，当所有函数都稳定了，如step2和step4，那么设计模式也就没有任何意义了。  
**设计模式最大的作用就是在变化和稳定中间寻找隔离点,*或者说把变化像小兔子一样关到笼子里，让他在笼子里随便跳，但不污染整个房间***   
常常的软件体系结构既有变化，也有稳定点，而不能假设两种极端的探讨。**在模式应用的时候，核心就是分辨软件体系结构哪些是稳定的哪些是变化的**

template2_lib.cpp
```c++
//程序库开发人员
class Library{
public:
	//稳定 template method
    void Run(){
        
        Step1();

        if (Step2()) { //支持变化 ==> 虚函数的多态调用
            Step3(); 
        }

        for (int i = 0; i < 4; i++){
            Step4(); //支持变化 ==> 虚函数的多态调用
        }

        Step5();

    }
	virtual ~Library(){ }

protected:
	
	void Step1() { //稳定
        //.....
        }
	void Step3() {//稳定
        //.....
        }
	void Step5() { //稳定
		//.....
	}

	virtual bool Step2() = 0;//变化
        virtual void Step4() =0; //变化
};
```
template2_app.cpp
```c++
//应用程序开发人员
class Application : public Library {
protected:
    virtual bool Step2(){
		//... 子类重写实现
    }

    virtual void Step4() {
		//... 子类重写实现
    }
};
int main(){
    {
        Library* pLib=new Application();
        lib->Run();

        delete pLib;
    }
}

```

### 对比（早绑定和晚绑定）
![](../pic/WeChat&#32;Image_20191029220344.png)
早绑定：晚的调用早的东西  
晚绑定：早的调用晚的东西
## 模式定义
定义一个操作中的算法的骨架 **(稳定)****(注：也就是第二种写法中的run)**，而将一些步骤**延迟****(注：虚函数)**(变化)到子类中。 Template Method使得子类可以不改变**(复用)**一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。——《设计模式》 GoF   
为什么叫模板(注：run就是一个模板)，类似的可以联想到c++的sort
## 类结构
今后在看设计模式的时候，都可以去画画类图哪些是稳定哪些是变化的，而不是说只看代码关系。  
以下为一个类图示例，红色的代表稳定的如run函数；蓝色的代表变化的如step2和step4。
![](../pic/WeChat&#32;Image_20191030194646.png)  
## 要点总结

- Template Method模式是一种**非常基础**性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（**虚函数的多态性**）为很多应用程序框架提供了灵活的**扩展点****（注：虚函数+子类继承）**，是代码复用方面的基本实现结构。
- 除了可以灵活应对子步骤的变化外，“**不要调用我，让我来调用你**”**(注：让库设计人员来调用应用程序开发人员具体化后的虚函数)**的反向控制结构是Template Method的典型应用。
- 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为**protected(注：因为这些单独作为一个public方法的意义不大，它往往要放到一个流程中才有意义)**方法。

**(注：虚函数是晚绑定的一种，而不是全部，比如函数指针也是晚绑定一种)**